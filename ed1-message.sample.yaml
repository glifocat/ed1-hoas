# ==============================================================================
# ED1 Message Display - Modular ESPHome Configuration
# ==============================================================================
#
# A message display with chat log functionality.
# - Receives messages from Home Assistant
# - Navigate with Up/Down buttons
# - Delete with X button
# - Messages persist until deleted
#
# Usage:
#   1. Copy this file and rename (e.g., ed1-fridge.yaml)
#   2. Change the substitutions below
#   3. Run: esphome run <your-config>.yaml
#
# To send a message from Home Assistant:
#   service: text.set_value
#   target:
#     entity_id: text.<device_name>_message
#   data:
#     value: "Your message here"
#
# ==============================================================================

substitutions:
  device_name: ed1-message
  friendly_name: ED1 Message Display
  ap_ssid: ED1-Message-Rescue

packages:
  colors: !include packages/display-colors.yaml
  layout: !include packages/display-layout.yaml
  core: !include packages/core.yaml
  hardware: !include packages/hardware.yaml
  display: !include packages/display.yaml
  fonts: !include packages/fonts.yaml
  buzzer: !include packages/buzzer.yaml
  buttons: !include packages/buttons.yaml
  sensors: !include packages/sensors.yaml

# Track HA connection
api:
  on_client_connected:
    - lambda: 'id(ha_connected) = true;'
  on_client_disconnected:
    - lambda: 'id(ha_connected) = false;'

# Time sync
time:
  - platform: sntp
    id: sntp_time
    timezone: Europe/Madrid

# Startup animation and globals
esphome:
  on_boot:
    priority: -100
    then:
      - rtttl.play: 'startup:d=16,o=5,b=180:c,e,g,c6'
      - delay: 3s
      - lambda: 'id(boot_complete) = true;'

globals:
  - id: boot_complete
    type: bool
    initial_value: 'false'
  - id: ha_connected
    type: bool
    initial_value: 'false'
  - id: message_list
    type: std::vector<std::string>
    restore_value: false
  - id: timestamp_list
    type: std::vector<std::string>
    restore_value: false
  - id: current_index
    type: int
    initial_value: '0'

# Message input from Home Assistant
text:
  - platform: template
    name: "${friendly_name} Message"
    id: display_message
    optimistic: true
    min_length: 0
    max_length: 200
    mode: text
    restore_value: true
    on_value:
      then:
        - lambda: |-
            if (x.length() > 0 && x != "None") {
              // Add message to the list
              id(message_list).insert(id(message_list).begin(), x);
              // Capture timestamp
              auto time = id(sntp_time).now();
              if (time.is_valid()) {
                char buf[20];
                snprintf(buf, sizeof(buf), "%02d:%02d", time.hour, time.minute);
                id(timestamp_list).insert(id(timestamp_list).begin(), std::string(buf));
              } else {
                id(timestamp_list).insert(id(timestamp_list).begin(), "??:??");
              }
              // Keep max 20 messages
              if (id(message_list).size() > 20) {
                id(message_list).pop_back();
                id(timestamp_list).pop_back();
              }
              // Reset to newest message
              id(current_index) = 0;
            }
        - rtttl.play: 'notify:d=8,o=5,b=140:c6,e6'

# Override button behaviors for message navigation
binary_sensor:
  - id: !extend btn_up
    on_press:
      - rtttl.play: 'beep:d=16,o=5,b=140:c'
      - lambda: |-
          // Navigate to older message
          if (id(current_index) < (int)id(message_list).size() - 1) {
            id(current_index)++;
          }
      - logger.log: "Button Up - Older message"

  - id: !extend btn_down
    on_press:
      - rtttl.play: 'beep:d=16,o=5,b=140:c'
      - lambda: |-
          // Navigate to newer message
          if (id(current_index) > 0) {
            id(current_index)--;
          }
      - logger.log: "Button Down - Newer message"

  - id: !extend btn_x
    on_press:
      - rtttl.play: 'alert:d=8,o=5,b=180:c,c,c'
      - lambda: |-
          // Delete current message
          if (!id(message_list).empty() && id(current_index) < (int)id(message_list).size()) {
            id(message_list).erase(id(message_list).begin() + id(current_index));
            id(timestamp_list).erase(id(timestamp_list).begin() + id(current_index));
            // Adjust index if needed
            if (id(current_index) >= (int)id(message_list).size() && id(current_index) > 0) {
              id(current_index)--;
            }
          }
      - logger.log: "Button X - Delete message"

# Message display layout - TE "Messenger" style
display:
  - id: !extend internal_display
    lambda: |-
      // ===========================================
      // COLORS (from display-colors.yaml)
      // ===========================================
      auto BG      = Color(${color_bg});
      auto TEXT    = Color(${color_text});
      auto MUTED   = Color(${color_muted});
      auto OK      = Color(${color_ok});
      auto WARN    = Color(${color_warn});
      auto ERR     = Color(${color_error});
      auto ACCENT  = Color(${color_accent});
      auto HIGHLIGHT = Color(${color_highlight});

      // ===========================================
      // LAYOUT (from display-layout.yaml)
      // ===========================================
      const int W = ${display_width};
      const int HEADER_H = ${header_height};
      const int CONTENT_Y = ${content_y};
      const int FOOTER_Y = ${footer_y};
      const int PAD = ${padding};

      // ===========================================
      // HELPER FUNCTIONS
      // ===========================================

      // Draw status bar (solid color block)
      auto draw_status_bar = [&]() {
        it.filled_rectangle(0, 0, W, HEADER_H, HIGHLIGHT);
      };

      // Draw connection dot
      auto draw_status_dot = [&](int x, int y, bool connected) {
        if (connected) {
          it.filled_circle(x, y, 4, OK);
        } else {
          int sec = (int)id(uptime_sensor).state;
          if (sec % 2 == 0) {
            it.filled_circle(x, y, 4, WARN);
          } else {
            it.circle(x, y, 4, WARN);
          }
        }
      };

      // Draw signal bars
      auto draw_signal_bars = [&](int x, int y) {
        int rssi = (int)id(wifi_signal_sensor).state;
        int bars = (rssi > -50) ? 4 : (rssi > -60) ? 3 :
                   (rssi > -70) ? 2 : (rssi > -80) ? 1 : 0;
        for (int i = 0; i < 4; i++) {
          int h = (i + 1) * 2;
          int bx = x + (i * 4);
          int by = y - h;
          if (i < bars) {
            it.filled_rectangle(bx, by, 3, h, BG);
          } else {
            it.rectangle(bx, by, 3, h, BG);
          }
        }
      };

      // Word wrap helper
      auto wrap_text = [](const std::string& text, int max_chars) {
        std::vector<std::string> lines;
        std::string remaining = text;
        while (!remaining.empty()) {
          if (remaining.length() <= max_chars) {
            lines.push_back(remaining);
            break;
          }
          size_t pos = remaining.rfind(' ', max_chars);
          if (pos == std::string::npos || pos == 0) pos = max_chars;
          lines.push_back(remaining.substr(0, pos));
          remaining = remaining.substr(pos);
          if (!remaining.empty() && remaining[0] == ' ')
            remaining = remaining.substr(1);
        }
        return lines;
      };

      // ===========================================
      // RENDER
      // ===========================================
      it.fill(BG);

      // Boot splash
      if (!id(boot_complete)) {
        it.filled_rectangle(0, 40, W, 30, HIGHLIGHT);
        it.print(W/2, 48, id(large_font), BG, TextAlign::CENTER, "ED1");
        it.print(W/2, 80, id(pixel_font), MUTED, TextAlign::CENTER, "BOOTING");
        return;
      }

      // --- HEADER (status bar) ---
      draw_status_bar();

      // Connection dot (left)
      bool connected = !id(wifi_ip).state.empty() && id(ha_connected);
      draw_status_dot(10, HEADER_H/2, connected);

      // Status text
      it.print(20, 6, id(pixel_font), BG, connected ? "ONLINE" : "OFFLINE");

      // Time (right-aligned)
      auto time = id(sntp_time).now();
      if (time.is_valid()) {
        it.strftime(W - PAD, 6, id(pixel_font), BG, TextAlign::TOP_RIGHT, "%H:%M", time);
      }

      // Navigation counter (far right, if messages exist)
      int msg_count = id(message_list).size();
      if (msg_count > 0) {
        char nav[8];
        snprintf(nav, sizeof(nav), "%d/%d", id(current_index) + 1, msg_count);
        it.print(W - 30, 6, id(pixel_font), BG, TextAlign::TOP_RIGHT, nav);
      }

      // Signal bars
      draw_signal_bars(${signal_x}, HEADER_H - 4);

      // --- CONTENT AREA ---
      if (msg_count == 0) {
        // Empty state
        it.print(W/2, 60, id(icons_12), MUTED, TextAlign::CENTER, "\U0000e0b7");
        it.print(W/2, 80, id(pixel_font), MUTED, TextAlign::CENTER, "no messages");
      } else {
        // Bounds check
        if (id(current_index) >= msg_count) id(current_index) = msg_count - 1;
        if (id(current_index) < 0) id(current_index) = 0;

        int idx = id(current_index);
        if (idx < 0 || idx >= (int)id(message_list).size() || idx >= (int)id(timestamp_list).size()) {
          return;
        }

        std::string msg = id(message_list)[idx];
        std::string ts = id(timestamp_list)[idx];

        // Timestamp (small, muted)
        it.printf(PAD, CONTENT_Y, id(pixel_font), MUTED, "%s", ts.c_str());

        // Message text (left-aligned, wrapped)
        auto lines = wrap_text(msg, 18);
        int y = CONTENT_Y + 14;
        int max_lines = 5;
        int line_num = 0;
        for (const auto& line : lines) {
          if (line_num >= max_lines) break;
          it.print(PAD, y, id(message_font), ACCENT, line.c_str());
          y += ${line_height};
          line_num++;
        }
      }

      // --- FOOTER ---
      it.horizontal_line(0, FOOTER_Y, W, MUTED);

      // Light level (left)
      it.printf(PAD, ${footer_text_y}, id(pixel_font), MUTED, "%.0f%%", id(light_sensor).state);

      // Delete hint (right)
      if (msg_count > 0) {
        it.print(W - PAD, ${footer_text_y}, id(pixel_font), ERR, TextAlign::TOP_RIGHT, "X DEL");
      }
