# ==============================================================================
# ED1 MQTT Monitor - Terminal-style MQTT message display
# ==============================================================================
#
# A monitor-style display for MQTT messages with a technical aesthetic.
# - Accent stripe indicates connection status
# - Shows MQTT topic and raw payload
# - Message counter and stats in footer
#
# Usage:
#   1. Copy this file and rename (e.g., ed1-kitchen.yaml)
#   2. Update substitutions below
#   3. Add MQTT credentials to secrets.yaml
#   4. Run: esphome run <your-config>.yaml
#
# To send a message:
#   mosquitto_pub -h BROKER -t ed1/<device_name>/message -m "Hello!"
#
# ==============================================================================

substitutions:
  device_name: ed1-mqtt
  friendly_name: ED1 MQTT Monitor
  ap_ssid: ED1-MQTT-Rescue
  mqtt_topic: "ed1/${device_name}/message"

packages:
  colors: !include packages/display-colors.yaml
  layout: !include packages/display-layout.yaml
  settings: !include packages/display-settings.yaml
  core: !include packages/core.yaml
  hardware: !include packages/hardware.yaml
  display: !include packages/display.yaml
  fonts: !include packages/fonts.yaml
  buzzer: !include packages/buzzer.yaml
  buttons: !include packages/buttons.yaml
  sensors: !include packages/sensors.yaml
  mqtt: !include packages/mqtt.yaml

# Globals for message display
globals:
  - id: boot_complete
    type: bool
    initial_value: 'false'
  # Message history (circular buffer)
  - id: msg_history
    type: std::vector<std::string>
    restore_value: false
  - id: msg_timestamps
    type: std::vector<std::string>
    restore_value: false
  - id: msg_history_index
    type: int
    initial_value: '0'
  - id: msg_scroll_offset
    type: int
    initial_value: '0'
  - id: msg_count
    type: int
    initial_value: '0'
  - id: msg_history_max
    type: int
    initial_value: '5'

# Startup
esphome:
  on_boot:
    priority: -100
    then:
      - script.execute: sound_startup
      - delay: 2s
      - lambda: 'id(boot_complete) = true;'

# Time sync for message timestamps
time:
  - platform: sntp
    id: sntp_time
    timezone: Europe/Madrid

# Extend MQTT message to store and display
text_sensor:
  - id: !extend mqtt_message
    on_value:
      then:
        - lambda: |-
            if (x.length() > 0) {
              // Get timestamp
              std::string timestamp;
              auto time = id(sntp_time).now();
              if (time.is_valid()) {
                char buf[10];
                snprintf(buf, sizeof(buf), "%02d:%02d", time.hour, time.minute);
                timestamp = std::string(buf);
              } else {
                timestamp = "??:??";
              }

              // Add to history (insert at front)
              id(msg_history).insert(id(msg_history).begin(), x);
              id(msg_timestamps).insert(id(msg_timestamps).begin(), timestamp);

              // Trim if over max
              int max_size = id(msg_history_max);
              if (id(msg_history).size() > max_size) {
                id(msg_history).resize(max_size);
                id(msg_timestamps).resize(max_size);
              }

              // Reset to newest message
              id(msg_history_index) = 0;
              id(msg_scroll_offset) = 0;
              id(msg_count)++;
            }
        - script.execute: sound_notify

# Button handlers
binary_sensor:
  # Clear current message with X button
  - id: !extend btn_x
    on_press:
      - script.execute: sound_alert
      - lambda: |-
          if (!id(msg_history).empty()) {
            int idx = id(msg_history_index);
            if (idx < id(msg_history).size()) {
              id(msg_history).erase(id(msg_history).begin() + idx);
              id(msg_timestamps).erase(id(msg_timestamps).begin() + idx);
              // Adjust index if needed
              if (id(msg_history_index) >= id(msg_history).size() && !id(msg_history).empty()) {
                id(msg_history_index) = id(msg_history).size() - 1;
              }
              id(msg_scroll_offset) = 0;
            }
          }
      - logger.log: "Message cleared"

  # Scroll up within message
  - id: !extend btn_up
    on_press:
      - lambda: |-
          if (id(msg_scroll_offset) > 0) {
            id(msg_scroll_offset) -= 1;
          }

  # Scroll down within message
  - id: !extend btn_down
    on_press:
      - lambda: |-
          id(msg_scroll_offset) += 1;

  # Navigate to older message (LEFT)
  - id: !extend btn_left
    on_press:
      - lambda: |-
          if (id(msg_history_index) < (int)id(msg_history).size() - 1) {
            id(msg_history_index)++;
            id(msg_scroll_offset) = 0;
          }

  # Navigate to newer message (RIGHT)
  - id: !extend btn_right
    on_press:
      - lambda: |-
          if (id(msg_history_index) > 0) {
            id(msg_history_index)--;
            id(msg_scroll_offset) = 0;
          }

# MQTT Monitor display - TE "Monitor" style
display:
  - id: !extend internal_display
    lambda: |-
      // ===========================================
      // COLORS (runtime palette selection)
      // ===========================================
      auto BG      = Color(${color_bg});
      auto TEXT    = Color(${color_text});
      auto MUTED   = Color(${color_muted});
      auto OK      = Color(${color_ok});
      auto WARN    = Color(${color_warn});
      auto ERR     = Color(${color_error});

      // Palette-dependent colors
      Color ACCENT, HIGHLIGHT;
      int palette = id(display_palette);
      if (palette == 0) {        // TE Orange
        HIGHLIGHT = Color(0,102,255);  // Orange
        ACCENT = Color(255,255,0);     // Cyan
      } else if (palette == 1) { // Cyber
        HIGHLIGHT = Color(255,0,255);  // Magenta
        ACCENT = Color(255,255,0);     // Cyan
      } else if (palette == 2) { // Mono Green
        HIGHLIGHT = Color(0,255,0);    // Green
        ACCENT = Color(0,200,0);       // Dim green
      } else {                   // Ocean
        HIGHLIGHT = Color(255,200,0);  // Teal
        ACCENT = Color(255,128,0);     // Light blue
      }

      // ===========================================
      // LAYOUT (from display-layout.yaml)
      // ===========================================
      const int W = ${display_width};
      const int HEADER_H = ${header_height};
      const int FOOTER_Y = ${footer_y};
      const int PAD = ${padding};

      // ===========================================
      // HELPER FUNCTIONS
      // ===========================================

      // Word wrap helper
      auto wrap_text = [](const std::string& text, int max_chars) {
        std::vector<std::string> lines;
        std::string remaining = text;
        while (!remaining.empty()) {
          if (remaining.length() <= max_chars) {
            lines.push_back(remaining);
            break;
          }
          size_t pos = remaining.rfind(' ', max_chars);
          if (pos == std::string::npos || pos == 0) pos = max_chars;
          lines.push_back(remaining.substr(0, pos));
          remaining = remaining.substr(pos);
          if (!remaining.empty() && remaining[0] == ' ')
            remaining = remaining.substr(1);
        }
        return lines;
      };

      // Signal bars helper - draws 4 vertical bars based on RSSI
      // x,y is top-right corner of the bars
      auto draw_signal_bars = [&](int x, int y, int rssi, Color ok, Color warn, Color err, Color muted) {
        // Determine signal level (0-4 bars)
        int bars = 0;
        Color color = err;
        if (rssi > -50) { bars = 4; color = ok; }
        else if (rssi > -60) { bars = 3; color = ok; }
        else if (rssi > -70) { bars = 2; color = warn; }
        else if (rssi > -80) { bars = 1; color = warn; }
        else { bars = 0; color = err; }

        // Draw 4 bars from left to right, heights: 3, 6, 9, 12
        int bar_w = 3;
        int gap = 1;
        int base_y = y + 12;  // Bottom baseline
        for (int i = 0; i < 4; i++) {
          int bar_h = 3 + (i * 3);  // Heights: 3, 6, 9, 12
          int bar_x = x - (4 - i) * (bar_w + gap);
          Color c = (i < bars) ? color : muted;
          it.filled_rectangle(bar_x, base_y - bar_h, bar_w, bar_h, c);
        }
      };

      // ===========================================
      // RENDER
      // ===========================================
      it.fill(BG);

      // Boot splash
      if (!id(boot_complete)) {
        it.filled_rectangle(0, 40, W, 30, HIGHLIGHT);
        it.print(W/2, 48, id(large_font), BG, TextAlign::CENTER, "MQTT");
        it.print(W/2, 80, id(pixel_font), MUTED, TextAlign::CENTER, "CONNECTING");
        return;
      }

      // --- HEADER with accent stripe ---
      // Left accent stripe (TE signature element)
      bool mqtt_ok = !id(wifi_ip).state.empty();
      it.filled_rectangle(0, 0, 3, HEADER_H, mqtt_ok ? HIGHLIGHT : WARN);

      // Title
      it.print(8, 6, id(pixel_font), HIGHLIGHT, "MQTT");

      // Connection status dot
      if (mqtt_ok) {
        it.filled_circle(45, 10, 3, OK);
        it.print(52, 6, id(pixel_font), OK, "LIVE");
      } else {
        int sec = (int)id(uptime_sensor).state;
        it.filled_circle(45, 10, 3, (sec % 2) ? WARN : BG);
        it.print(52, 6, id(pixel_font), WARN, "WAIT");
      }

      // Signal bars (right)
      int rssi = (int)id(wifi_signal_sensor).state;
      draw_signal_bars(W - PAD, 4, rssi, OK, WARN, ERR, MUTED);

      it.horizontal_line(0, HEADER_H, W, MUTED);

      // --- TOPIC BAR ---
      it.filled_rectangle(0, HEADER_H, W, 12, MUTED);
      it.print(PAD, HEADER_H + 2, id(pixel_font), TEXT, "${mqtt_topic}");

      // --- MESSAGE AREA ---
      int content_y = HEADER_H + 14;
      int history_size = id(msg_history).size();
      int current_idx = id(msg_history_index);

      if (history_size == 0) {
        // Empty state - terminal prompt style
        it.print(PAD, 50, id(pixel_font), MUTED, "> waiting for");
        it.print(PAD, 62, id(pixel_font), MUTED, "  message...");
        it.print(PAD, 80, id(pixel_font), ACCENT, "_");
      } else {
        // Ensure index is valid
        if (current_idx >= history_size) current_idx = history_size - 1;

        std::string current_msg = id(msg_history)[current_idx];
        std::string current_time = id(msg_timestamps)[current_idx];

        // Timestamp + position indicator
        if (history_size > 1) {
          it.printf(PAD, content_y, id(pixel_font), MUTED, "%s [%d/%d]",
                    current_time.c_str(), current_idx + 1, history_size);
        } else {
          it.printf(PAD, content_y, id(pixel_font), MUTED, "%s", current_time.c_str());
        }

        // Message payload (wrapped)
        auto lines = wrap_text(current_msg, 16);

        // Clamp scroll
        int max_scroll = lines.size() > 4 ? lines.size() - 4 : 0;
        if (id(msg_scroll_offset) > max_scroll) id(msg_scroll_offset) = max_scroll;

        int y = content_y + 14;
        int visible_lines = 4;
        int offset = id(msg_scroll_offset);

        for (int i = 0; i < visible_lines && (offset + i) < (int)lines.size(); i++) {
          it.print(PAD, y, id(message_font), ACCENT, lines[offset + i].c_str());
          y += ${line_height};
        }

        // Scroll indicators (vertical)
        if (offset > 0) {
          it.print(W - 8, content_y + 14, id(pixel_font), MUTED, "^");
        }
        if (offset < max_scroll) {
          it.print(W - 8, content_y + 14 + (visible_lines - 1) * ${line_height}, id(pixel_font), MUTED, "v");
        }

        // History navigation indicators (horizontal arrows on sides)
        if (current_idx < history_size - 1) {
          it.print(PAD, content_y + 40, id(pixel_font), MUTED, "<");  // older
        }
        if (current_idx > 0) {
          it.print(W - PAD - 6, content_y + 40, id(pixel_font), MUTED, ">");  // newer
        }
      }

      // --- FOOTER ---
      it.horizontal_line(0, FOOTER_Y, W, MUTED);

      // Message count (left)
      it.printf(PAD, ${footer_text_y}, id(pixel_font), MUTED, "#%d", id(msg_count));

      if (history_size > 0) {
        // Navigation hints (center)
        std::string nav_hint = "";
        if (history_size > 1) nav_hint += "< > ";
        auto lines = wrap_text(id(msg_history)[current_idx], 16);
        if (lines.size() > 4) nav_hint += "^ v";
        if (!nav_hint.empty()) {
          it.print(W/2, ${footer_text_y}, id(pixel_font), MUTED, TextAlign::TOP_CENTER, nav_hint.c_str());
        }
        // Clear hint (right)
        it.print(W - PAD, ${footer_text_y}, id(pixel_font), ERR, TextAlign::TOP_RIGHT, "X");
      } else {
        // Show IP when no message
        it.print(W - PAD, ${footer_text_y}, id(pixel_font), ACCENT, TextAlign::TOP_RIGHT,
                 id(wifi_ip).state.c_str());
      }
